<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>http详解</title><meta name="description" content="~ ~ ~"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/conor.github.io/images/favicon.png"><link rel="stylesheet" href="/conor.github.io/style/common/bulma.css"><link rel="stylesheet" href="/conor.github.io/style/base.css"><link rel="stylesheet" href="/conor.github.io/style/common/helper.css"><script src="/conor.github.io/js/common.js"></script><link rel="stylesheet" href="/conor.github.io/style/post.css"><link rel="stylesheet" href="/conor.github.io/style/themes/highlight-theme-light.css"><script src="/conor.github.io/js/highlight.pack.js"></script><meta name="description" content="什么是http协议：引用百度百科的话说来就是：http协议其实就是超文本传输协议，超文本传输协议 (HTTP-Hypertext transfer protocol) 是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。目前我们使用的http版本是http/1.1其前身是http/1.0。关于两个版本不同，下面会不时提及。在整个iso传输层次模型中http处于最高层次，而tcp是处于下面一层传输层，也就是说http是基于tcp协议建立的连接，所以http传输建立之前需要先建立tcp连接，也就是三次握手，在建立tcp连接之后方可真正请求响应请求。
http传输过程详解：当我们发送一个ajax请求，或者地址栏输入url后，我们的浏览器就给web服务器发送一个reque.."><meta name="generator" content="Hexo 5.4.0"></head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/conor.github.io/">Conor.Jin's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">http详解</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/conor.github.io/">首页</a></h3><h3 class="is-inline-block"><a href="/conor.github.io/about">关于</a></h3><h3 class="is-inline-block"><a href="/conor.github.io/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/conor.github.io/">首页</a></h3><h3 class="is-inline-block"><a href="/conor.github.io/about">关于</a></h3><h3 class="is-inline-block"><a href="/conor.github.io/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile is-hidden"></div><div class="column is-9"><header class="my-4"><a href="/conor.github.io/tags/%E7%BD%91%E7%BB%9C"><i class="tag post-item-tag">网络</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">http详解</h1><time class="has-text-grey" datetime="2018-09-05T08:07:32.000Z">2018-09-05</time><article class="mt-2 post-content"><p>什么是http协议：<br>引用百度百科的话说来就是：http协议其实就是超文本传输协议，超文本传输协议 (HTTP-Hypertext transfer protocol) 是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。目前我们使用的http版本是http/1.1其前身是http/1.0。关于两个版本不同，下面会不时提及。在整个iso传输层次模型中http处于最高层次，而tcp是处于下面一层传输层，也就是说http是基于tcp协议建立的连接，所以http传输建立之前需要先建立tcp连接，也就是三次握手，在建立tcp连接之后方可真正请求响应请求。</p>
<p>http传输过程详解：<br>当我们发送一个ajax请求，或者地址栏输入url后，我们的浏览器就给web服务器发送一个request，之后服务器处理完成后返回响应的response给浏览器。之后浏览器拿到数据进行解析里面数据从而生成我们页面或者组装数据。</p>
<p>期间传输还有可能经历了代理服务器（目前很多很多网站都用代理服务器，主要原因是其隐蔽。。）从而实现服务器端文件缓存。</p>
<p>http传输是面向连接的，也就是说如果连接没有中断，可以继续发送请求，这个设置可以在请求头Connection来设置，例如：我通过一个url请求了一个html页面之后，</p>
<p>经解析，html页面中包含对图片的请求，则会直接再向服务器发起请求而不必重新建立tcp连接。等到所有请求都就绪，方可完成一次页面加载或者请求完毕。</p>
<p>url详解：<br>无论是ajax请求还是地址栏输入url，都要用到请求地址，请求地址用来描述需要请求的资源位置以及筛选方式：大体结构如下</p>
<p><a target="_blank" rel="noopener" href="http://www.jindk.wang/blog/index.php/2018/09/05/duplicateremoval/index.html?name=yuchao&amp;age=26#modfiled">http://www.jindk.wang/blog/index.php/2018/09/05/duplicateremoval/index.html?name=yuchao&amp;age=26#modfiled</a></p>
<p>这个url分为几个部分：</p>
<p>http：表示底层使用的协议（如http、https、ftp）</p>
<p><a href="http://www.jindk.wang：表示服务器域名（或者是ip地址）">www.jindk.wang：表示服务器域名（或者是ip地址）</a></p>
<p>/blog/index.php/2018/09/05/duplicateremoval/：表示资源路径</p>
<p>?name=yuchao&amp;age=26：发送给服务器数据</p>
<p>#modfiled：锚点</p>
<p>http消息结构：<br>整个http消息结构分为request以及response两部分：为了便于讲解，我从w3c截取一个图如下：</p>
<p><img src="/images/httpdetails/20131226161724328.png"></p>
<p>这是从chrome的Network截图，且不管每个浏览器将其如何区分，按照我们看到的来分组：</p>
<p>上面第一部分是请求资源地址以及请求方式属于request部分</p>
<p>第二部分是返回状态码，属于response部分</p>
<p>第三部分是request部分，第四部分是response部分。</p>
<p>总体来说整个请求分为两个部分我们来分析里面主要的结构如下：</p>
<p>request部分分析：<br>请求的url即我们地址栏输入的url或者ajax请求的那个参数url。</p>
<p>请求方式：常用的有get、post以及head请求：</p>
<p>head请求：head请求是一种返回不呈现数据的请求，也就是只请求一个报文头，通常用于请求一个文件去判断文件是否更新或者在我的项目中去请求服务器时间。</p>
<p>get与post比较：</p>
<p>get请求一般都会用来查询资源信息，post请求一般会用来更新资源信息。</p>
<p>get提交数据方式是将参数放置url之后用&amp;来分开例如<a target="_blank" rel="noopener" href="http://www.temas.com/myBlog/file/date.php?name=yuchao&amp;age=26%EF%BC%8C">http://www.temas.com/myBlog/file/date.php?name=yuchao&amp;age=26，</a></p>
<p>post请求可以以对象字面量形式进行参数传输：{name:”yuchao”;age:”26″}，所以通过post方式发送的请求中包含内容这一项，而get请求直接将内容附在url之后</p>
<p>正是由于数据传输方式不同导致get传输数据量需要在url字节限制范围之内，而post几乎无限制。同时get参数放置于url中也不利于安全。</p>
<p>Accept：表示浏览器可以接受的类型，一般浏览器都会发给服务器*表示通配所有类型。text/html类型就表示我们常说的html文档。</p>
<p>当我们规定了一种类型时候而服务器没有这种类型可以返回，则会抛出一个406状态码的错误(no acceptable)</p>
<p>Accept-Encoding：浏览器自身声明接受的编码方式，通常是压缩方法；</p>
<p>Accept-Language：浏览器自身声明可以接受的语言例如中文：zh-CN；</p>
<p>cookie:将cookie数据发送给服务器</p>
<p>Connection：可选值有：</p>
<p>keep-alive:当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接，</p>
<p>重新向该服务器发送请求时候不会重新经过三次握手建立链接，而是直接可以进行请求，这个请求时间段可以由服务器端Keep-Alive字段进行设置，</p>
<p>当过了这个时间段之后没有任何请求则关闭该连接。http1.0中默认是close，而目前应用的1.1版本中默认是keep-alive长连接。具体应用看下面response介绍该key；</p>
<p>Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</p>
<p>User-Agent：客户端使用的浏览器以及操作系统</p>
<p>Cache-Control：浏览器缓存机制，一般会有max-age=值，或者no-cache或者public、private；</p>
<p>If-Modified-Since：浏览器缓存内容最后修改时间;</p>
<p>if-None-Match:和ETag一起工作，比较两者值 获取内容是否改变。</p>
<p>response部分分析：<br>status：返回状态码，</p>
<p>HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别</p>
<p>100-199  提示信息 – 表示请求已被成功接收，继续处理</p>
<p>200-299  成功 – 表示请求已被成功接收，理解，接受</p>
<p>300-399  重定向 – 要完成请求必须进行更进一步的处理</p>
<p>400-499  客户端错误 –  请求有语法错误或请求无法实现</p>
<p>500-599  服务器端错误 –   服务器未能实现合法的请求</p>
<p>我们来看一下一些常见的状态码：</p>
<p>200：OK，表明请求成功完成，所有资源成功发送给客户端；</p>
<p>302：重定向，例如google在中国被黑掉之后，只能转战利用香港服务器去请求，我们输入<a target="_blank" rel="noopener" href="http://www.google.com,/">www.google.com，</a></p>
<p>服务器就会返回302 Found，并且客户端接收到的response中location字段包含一个新的url地址，然后浏览器会根据这个地址重新发送一个新url的request；</p>
<p>304：使用的缓存文件</p>
<p>400：客户端请求与语法错误，不能被服务器解读；</p>
<p>403：服务器拒绝服务；</p>
<p>404：请求资源不存在；</p>
<p>500 Internal Server Error 服务器发生了不可预期的错误503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>
<p>Keep-Alive:长连接设置的值，如下图截图：</p>
<p><img src="/images/httpdetails/20131227131225609.jpg"></p>
<p>有两个值：timeout以及max，例如：Keep-Alive:timeout=5,max=100，只有当connection为keep-alive并且服务端支持时候才会生效。</p>
<p>其中timeout表示超时时间，max表示最大连接数。即：在5秒之内服务器始终保持空闲连接，在这五秒之内可以发送请求不必重新建立连接，超过这个时间则会重新建立连接进行请求。</p>
<p>在保持持久连接之间每发送一个请求max值就会减少一个，直到为0为止则会自动断开连接。</p>
<p>一般实际开发中，这个值的设置要根据具体网页中嵌入的请求个数去设置：例如网页中有20个图片，五个外部脚本，三个css样式表。则可以根据传输速度设置超时时间5-20秒之内，max值设置为30-100；</p>
<p>这样设计初衷就是为了既能减少不必要的tcp连接，又能避免频繁的请求造成服务器连接池冗余。</p>
<p>这个值从根本上来说跟前端没有太多关系，但是在网站性能优化很是关键。选择多次建立tcp连接还是选择空余一段时间请求被浪费，就要看实际需求以及能否设置出一个合理的Keep-Alive值</p>
<p>Conent-Length：表示返回实体内容长度大小，一般应用在返回静态页面或者一张图片并且数据量不大时候被设置；大小为bite字节；例如一张图片的请求：Connent-Length：630；请求一个图片截图如下：</p>
<p><img src="/images/httpdetails/20131227131410171.jpg"></p>
<p>Transfer-Encoding：即服务器端不是一个已知的固定的返回实体时候，服务器会一边产生数据，一边发送给客户端，</p>
<p>这时候服务器就需要用Transfer-Encoding：chunked分块编码来代替Conent-Length，设置该key后Content-Length就失效了。</p>
<p>对于前段来说只需关心返回的状态是否是成功即可，但是对于后台需要用到这个设置来判断客户端是否接受完全部数据。详细请参考</p>
<p>Date：服务器返回数据时间，我经常就用这个值来取得服务器时间</p>
<p>Etag：与if-modified-since配合使用；</p>
<p>Last-Modified:作用： 用于指示资源的最后修改日期和时间。一般都用来处理缓存，</p>
<p>Content-Type：作用：WEB服务器告诉浏览器自己响应的对象的类型和字符集,例如:Content-Type: text/html; charset=utf-8，Content-Type: image/jpeg</p>
<p>server：指明服务器软件版本；</p>
<p>Referer：告诉服务器该请求是在哪个链接发过来的，据此可以统计从某个页面跳转过来次数；</p>
<p>X-powered0by：表示该网站开发技术</p>
<p>ajax修改获取header：<br>利用xmlHttp.setRequestHeader来设置request请求头：例如：xmlHttp.setRequestHeader(‘cache-control’,’no-cache’);</p>
<p>利用xmlHttp.getResponseHeader来获取response头信息;例如：xmlHttp.getResponseHeader(“Date”)；</p>
<p>另外 request.setCharacterEncoding(“UTF-8”)也可以设置发送到服务端数据编码格式（一般来说发送的编码格式跟服务端解析格式必须是一致的）</p>
<p>链接参考：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012545279/article/details/17579155">https://blog.csdn.net/u012545279/article/details/17579155</a></p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/conor.github.io/2021/04/08/hexoInit/" title="hexo初始化"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: hexo初始化</span></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Conor-Jin"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Conor.Jin 2021</span></p></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/conor.github.io/js/post.js"></script></body></html>